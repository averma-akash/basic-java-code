Spring WebFlux is parallel version of Spring MVC and supports fully non-blocking reactive streams. It support the back pressure concept and uses Netty as inbuilt server to run reactive applications. 

************** Blocking request processing **************
	
In traditional MVC applications, when a request come to server, a servlet thread is created. It delegates the request to worker threads for I/O operations such as database access etc. During the time worker threads are busy, servlet thread (request thread) remain in waiting status and thus it is blocked. It is also called synchronous request processing.

************** Non-blocking request processing **************

In non-blocking or asynchronous request processing, no thread is in waiting state. There is generally only one request thread receiving the request.

All incoming requests come with a event handler and call back information. Request thread delegates the incoming requests to a thread pool (generally small number of threads) which delegate the request to it’s handler function and immediately start processing other incoming requests from request thread.

When the handler function is complete, one of thread from pool collect the response and pass it to the call back function.

************** Mono and Flux **************

In Spring WebFlux, the data returned from any operation is packed into a reactive stream. There are two types that embody this approach and are the building blocks in WebFlux applications - Mono and Flux.

Mono is a stream which returns zero items or a single item (0..1), whereas Flux is a stream which returns zero or more items (0..N).

Mono is therefore used when you're expecting a single (or none) result, such as retrieving a unique user from the database, whereas Flux is used when you're expecting multiple results or a collection of some sort.

************** WebClient **************

WebClient is a fully reactive client for making HTTP requests and was introduced by Spring WebFlux as an alternative to the RestTemplate. It is used for making calls to external APIs or webservices and it can also be used in synchronous workflows.

For creating a WebClient instance we can use the WebClient.create() or the WebClient .builder() methods depending on the settings we want to configure.
WebClient webClient = WebClient.builder().baseUrl("www.google.om").build();

The methods retrieve() and exchange() are used to manage the response by converting it into a publisher or a response entity object. The exchange() method will give you access to the complete response, not only the body. In order to use the response or just print it to the console we need to subscribe to the publisher.

WebClient.get().retreive().bodyToFlux(User.class).subscribe(System.out :: println);

************** WebTestClient **************

WebTestClient is used for testing WebFlux endpoints and it internally uses a WebClient instance. The WebTestClient can be bound to a real server or to a controller, a router function or an application context.

Once the instance of the WebTestClient is created, methods that are similar to WebClient’s methods can be used to prepare the requests. For performing the request, we need to use the exchange() method. The exchange() method returns a WebTestClient.ResponseSpec object which has some useful methods to verify the response like the expectStatus, expectBody, and expectHeader methods

The following is an example of a simple test to check the results of a get call to retrieve all the users:
List<User> expectedUserList = repository.findAll().collectList().block();
WebTestClient.bindToController(UserController)
.configureClient()
.baseUrl("/User")
.build()
.get()
.uri("/")
.exchane()
.expectStatus().isOk()
.expectBodyList(User.class).isEqualto(expectedUserList);