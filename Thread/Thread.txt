1. ******* Thread *******
a thread is a part of an application that shares a common memory with other threads of the same application.

2. ******* Different state of Thread ? *******

NEW — a new Thread instance that was not yet started via Thread.start()
RUNNABLE — a running thread. It is called runnable because at any given time it could be either running or waiting for the next quantum of time from the thread scheduler. A NEW thread enters the RUNNABLE state when you call Thread.start() on it
BLOCKED — a running thread becomes blocked if it needs to enter a synchronized section but cannot do that due to another thread holding the monitor of this section
WAITING — a thread enters this state if it waits for another thread to perform a particular action. For instance, a thread enters this state upon calling the Object.wait() method on a monitor it holds, or the Thread.join() method on another thread
TIMED_WAITING — same as the above, but a thread enters this state after calling timed versions of Thread.sleep(), Object.wait(), Thread.join() and some other methods
TERMINATED — a thread has completed the execution of its Runnable.run() method and terminated


4. ***** Broken Barrier ******

A barrier breaks when any of the waiting thread leaves the barrier. This happens when one or more waiting thread is interrupted or when the waiting time is completed because the thread called the await() methods with a timeout as follows:

newBarrier.await(1000, TimeUnit.MILLISECONDS);
// thread calling this await() 
// methods waits for only 1000 milliseconds.
When the barrier breaks due to one of more participating threads, the await() methods of all the other threads throws a BrokenThreadException. Whereas, the threads that are already waiting in the barriers have their await() call terminated.

5. ***** Executor Framework ******

The Executor Framework contains a bunch of components that are used to efficiently manage multiple threads. It was released with the JDK 5 which is used to run the Runnable objects without creating new threads every time and also mostly re-using the already created threads.

There are mainly 4 types of Executors available.

SingleThreadExecutor
FixedThreadPool
CachedThreadPool
ScheduledExecutor

********** Thread Pool **********

A Thread pool in Java is a group of worker threads that can be reused many times and assigned jobs.

A Thread pool contains a group of fixed size threads. Each thread is pulled out from the thread pool and assigned a task by the service provider. Once the assigned job is completed, the thread is given to the thread pool again.

Thread pool is advantageous as we do not have to create a new thread every time the task is available, thereby the performance is enhanced. It is used in real-time applications that use Servlet and JSP where thread pools are used to process requests.

In multi-threaded applications, the Thread Pool saves resources and helps to contain the parallelism within predefined limits.

import java.util.concurrent.ExecutorService;  
import java.util.concurrent.Executors;  
class WorkerThreadClass implements Runnable {  
    private String message;  
    //thread class constructor   
    public WorkerThreadClass(String s){  
        this.message=s;  
    }  
    //run method for thread
     public void run() {  
        System.out.println(" Start: "+message);  
        processmessage();  //sleep between start and end  
        System.out.println(" End: "+ message);  
    }
    //processmessage method =&amp;amp;gt; sleeps the thread for 2 sec
    private void processmessage() {  
        try {  Thread.sleep(2000);  } catch (InterruptedException e) { e.printStackTrace(); }  
    }  
}  
 
public class Main {  
     public static void main(String[] args) { 
         //create a ExecutorService instance
        ExecutorService executor = Executors.newFixedThreadPool(5);//creating a pool of 5 threads  
        //create thread instances and execute them
        for (int i = 0; i &amp;amp;lt; 5; i++) {  
            Runnable workerThrd = new WorkerThreadClass("Thread_" + i);  
            executor.execute(workerThrd);//calling execute method of ExecutorService  
          }  
        //shutdown ExecutorService
        executor.shutdown();  
        while (!executor.isTerminated()) {   }  
   
        System.out.println("Finished all threads");  
    }  
 }